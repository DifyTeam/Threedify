// ray.js - ULTIMATE FIX (Correct Adaptive Sampling + NEE + Speed)

// --- VARIÁVEIS GLOBAIS ---
let rayCanvas = null;
let rayCtx = null;
let rayIsRendering = false;
let raySamples = 0;
let rayImageData = null;

// BUFFERS PRINCIPAIS
let rayAccumulationBuffer = null;
let raySumSqBuffer = null;
let rayNormalDepthBuffer = null;
let raySampleCountBuffer = null; // NOVO: Conta quantos samples cada pixel recebeu

let rayWorkers = [];
let rayNumWorkers = navigator.hardwareConcurrency || 4;
let rayRenderButton = null;

// TILE RENDERING VARIABLES
const TILE_SIZE = 64; 
let rayTileQueue = [];
let rayActiveWorkersCount = 0;
let rayTileConvergence = []; 

// ARRAYS DE DADOS GEOMÉTRICOS
let rayTriangleData = null;
let rayNormalData = null; 
let rayUVData = null; 
let rayMaterialData = null;
let rayEmissiveTrianglesData = null; 
let rayEmissiveCount = 0;

let rayTextureList = []; 
let rayTotalTriangles = 0;

// SKYBOX
let raySkyboxImage = null;
let raySkyboxData = null;
let raySkyboxWidth = 0;
let raySkyboxHeight = 0;

// BVH STRUCTURES
let rayBVHBounds = null;
let rayBVHContents = null;
let rayBVHIndices = null;

// CONFIGURAÇÕES
const rayConfig = {
    maxSamples: 50,       
    samplesPerFrame: 1,
    maxBounces: 600, 
    pixelRatio: 1.0,        
    backgroundColor: [100/255, 100/255, 100/255, 1],
    denoise: false,        
    useSkybox: true,
    
    // CAMERA
    aperture: 0.0,         
    focusDistance: 10.0,   
    
    // ADAPTIVE SAMPLING
    adaptiveEnabled: true,
    varianceThreshold: 0.0005, 

    // AO
    aoEnabled: true,
    aoSamples: 2,
    aoRadius: 1.0,
    aoIntensity: 0.5
};

let raySceneData = null;
let rayCamera = {
    position: { x: 0, y: 0, z: 0 },
    target: { x: 0, y: 0, z: 0 },
    fov: 60,
    aspect: 1
};

// --- CONSTANTES BVH ---
const BVH_NODE_SIZE = 6;
const BVH_CONTENT_SIZE = 4;

// --- FUNÇÕES AUXILIARES ---
function rayLoadSkybox(imagePath) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            raySkyboxImage = img;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            raySkyboxWidth = img.width;
            raySkyboxHeight = img.height;
            raySkyboxData = new Float32Array(img.width * img.height * 4);
            for (let i = 0; i < imageData.data.length; i++) {
                raySkyboxData[i] = imageData.data[i] / 255.0;
            }
            rayConfig.useSkybox = true;
            console.log(`Skybox loaded: ${img.width}x${img.height}`);
            resolve();
        };
        img.onerror = () => {
            console.error('Failed to load skybox image:', imagePath);
            rayConfig.useSkybox = false;
            reject(new Error('Failed to load skybox'));
        };
        img.src = imagePath;
    });
}

function rayExtractTexture(img) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const ctx = tempCanvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const imgData = ctx.getImageData(0, 0, img.width, img.height);
    const floatData = new Float32Array(imgData.data.length);
    for(let i=0; i<imgData.data.length; i++) {
        floatData[i] = imgData.data[i] / 255.0;
    }
    return { width: img.width, height: img.height, data: floatData };
}

function rayCountTrianglesRecursive(objects) {
    let count = 0;
    for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        if (obj.userData && obj.userData.isLight) continue;
        if (obj.isMesh && obj.visible !== false && obj.geometry) {
            const geo = obj.geometry;
            if (geo.index) count += geo.index.count / 3;
            else if (geo.attributes.position) count += geo.attributes.position.count / 3;
        }
        if (obj.children && obj.children.length > 0) count += rayCountTrianglesRecursive(obj.children);
    }
    return count;
}

function rayFillBuffersRecursive(objects, cursor, emissiveCollector) {
    for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        if (obj.userData && obj.userData.isLight) continue;

        if (obj.isMesh && obj.geometry && obj.visible !== false) {
            obj.updateMatrixWorld(true);
            const geo = obj.geometry;
            const positions = geo.attributes.position.array;
            const normals = geo.attributes.normal ? geo.attributes.normal.array : null;
            const indices = geo.index ? geo.index.array : null;
            const uvs = geo.attributes.uv ? geo.attributes.uv.array : null;
            
            const mw = obj.matrixWorld.elements;
            let r=0.7, g=0.7, b=0.7;
            let roughness = 0.5;
            let emR=0, emG=0, emB=0;
            let metalnessValue = 0.0;
            let transmissionValue = 0.0;
            let textureId = -1.0;
            let isFlatShading = false;
            
            if (obj.material) {
                const m = obj.material;
                if(m.color) { r=m.color.r; g=m.color.g; b=m.color.b; }
                if (m.map && m.map.image) {
                    const texData = rayExtractTexture(m.map.image);
                    textureId = rayTextureList.length;
                    rayTextureList.push(texData);
                }
                
                if (m.rayemission !== undefined && m.rayemission > 0) {
                    const intensity = m.rayemission * 5.0; 
                    emR = r * intensity; emG = g * intensity; emB = b * intensity;
                } else if(m.emissive) { 
                    const intensity = (m.emissiveIntensity !== undefined) ? m.emissiveIntensity : 1.0;
                    emR=m.emissive.r * intensity * 5.0; 
                    emG=m.emissive.g * intensity * 5.0; 
                    emB=m.emissive.b * intensity * 5.0; 
                }
                
                if (m.rayroughness !== undefined && m.rayroughness !== null) {
                    roughness = parseFloat(m.rayroughness);
                } else if (m.roughness !== undefined && m.roughness !== null) {
                    roughness = parseFloat(m.roughness);
                }
                roughness = Math.max(0.0, Math.min(1.0, roughness));

                if (m.raymetalness !== undefined) metalnessValue = m.raymetalness;
                else if (m.metalness !== undefined) metalnessValue = m.metalness;

                if (m.transmission !== undefined) transmissionValue = m.transmission;
                if (m.rayreflection !== undefined) transmissionValue = m.rayreflection; 
                if (m.opacity < 1.0) transmissionValue = 1.0 - m.opacity;

                if (m.flatShading === true) isFlatShading = true;
            }

            const transformAndStore = (x, y, z, offset) => {
                const tx = x * mw[0] + y * mw[4] + z * mw[8] + mw[12];
                const ty = x * mw[1] + y * mw[5] + z * mw[9] + mw[13];
                const tz = x * mw[2] + y * mw[6] + z * mw[10] + mw[14];
                rayTriangleData[offset] = tx;
                rayTriangleData[offset+1] = ty; rayTriangleData[offset+2] = tz;
                return {x: tx, y: ty, z: tz};
            };

            const transformAndStoreNormal = (x, y, z, offset) => {
                const nx = x * mw[0] + y * mw[4] + z * mw[8];
                const ny = x * mw[1] + y * mw[5] + z * mw[9];
                const nz = x * mw[2] + y * mw[6] + z * mw[10];
                const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                if (len > 0) {
                    rayNormalData[offset] = nx/len; 
                    rayNormalData[offset+1] = ny/len; 
                    rayNormalData[offset+2] = nz/len;
                } else {
                    rayNormalData[offset] = 0; rayNormalData[offset+1] = 1; rayNormalData[offset+2] = 0;
                }
            };

            const triCount = indices ? (indices.length / 3) : (positions.length / 9);
            for (let t = 0; t < triCount; t++) {
                let i0, i1, i2;
                if (indices) {
                    i0 = indices[t*3]; i1 = indices[t*3+1]; i2 = indices[t*3+2];
                } else {
                    i0 = t * 3; i1 = t * 3 + 1; i2 = t * 3 + 2;
                }
                if ((i0*3)+2 >= positions.length || (i1*3)+2 >= positions.length || (i2*3)+2 >= positions.length) continue;

                const baseIdx = cursor.index * 9;
                const uvBaseIdx = cursor.index * 6;
                const matIdx = cursor.index * 11;
                
                const v0x = positions[i0*3], v0y = positions[i0*3+1], v0z = positions[i0*3+2];
                const v1x = positions[i1*3], v1y = positions[i1*3+1], v1z = positions[i1*3+2];
                const v2x = positions[i2*3], v2y = positions[i2*3+1], v2z = positions[i2*3+2];
                if (isNaN(v0x) || isNaN(v1x) || isNaN(v2x)) continue;
                
                const w0 = transformAndStore(v0x, v0y, v0z, baseIdx);
                const w1 = transformAndStore(v1x, v1y, v1z, baseIdx+3);
                const w2 = transformAndStore(v2x, v2y, v2z, baseIdx+6);

                if (emR > 0 || emG > 0 || emB > 0) {
                    emissiveCollector.push({
                        v0: w0, v1: w1, v2: w2,
                        emission: {r: emR, g: emG, b: emB}
                    });
                }

                if (normals && !isFlatShading) {
                    transformAndStoreNormal(normals[i0*3], normals[i0*3+1], normals[i0*3+2], baseIdx);
                    transformAndStoreNormal(normals[i1*3], normals[i1*3+1], normals[i1*3+2], baseIdx+3);
                    transformAndStoreNormal(normals[i2*3], normals[i2*3+1], normals[i2*3+2], baseIdx+6);
                } else {
                    const e1x = v1x - v0x, e1y = v1y - v0y, e1z = v1z - v0z;
                    const e2x = v2x - v0x, e2y = v2y - v0y, e2z = v2z - v0z;
                    let nx = e1y * e2z - e1z * e2y;
                    let ny = e1z * e2x - e1x * e2z;
                    let nz = e1x * e2y - e1y * e2x;
                    transformAndStoreNormal(nx, ny, nz, baseIdx);
                    transformAndStoreNormal(nx, ny, nz, baseIdx+3);
                    transformAndStoreNormal(nx, ny, nz, baseIdx+6);
                }

                if (uvs) {
                    rayUVData[uvBaseIdx] = uvs[i0*2]; rayUVData[uvBaseIdx+1] = uvs[i0*2+1];
                    rayUVData[uvBaseIdx+2] = uvs[i1*2]; rayUVData[uvBaseIdx+3] = uvs[i1*2+1];
                    rayUVData[uvBaseIdx+4] = uvs[i2*2]; rayUVData[uvBaseIdx+5] = uvs[i2*2+1];
                } else {
                    rayUVData[uvBaseIdx] = 0; rayUVData[uvBaseIdx+1] = 0;
                    rayUVData[uvBaseIdx+2] = 0; rayUVData[uvBaseIdx+3] = 0;
                    rayUVData[uvBaseIdx+4] = 0; rayUVData[uvBaseIdx+5] = 0;
                }

                rayMaterialData[matIdx] = r; rayMaterialData[matIdx+1] = g; rayMaterialData[matIdx+2] = b;
                rayMaterialData[matIdx+3] = roughness; 
                rayMaterialData[matIdx+4] = 0; 
                rayMaterialData[matIdx+5] = emR; rayMaterialData[matIdx+6] = emG; rayMaterialData[matIdx+7] = emB;
                rayMaterialData[matIdx+8] = metalnessValue; 
                rayMaterialData[matIdx+9] = transmissionValue;
                rayMaterialData[matIdx+10] = textureId;
                cursor.index++;
            }
        }
        if (obj.children && obj.children.length > 0) rayFillBuffersRecursive(obj.children, cursor, emissiveCollector);
    }
}

function rayBuildFlatBVH(triangleIndices) {
    const nodes = [];
    const BINS = 8; 

    function getTriangleBounds(idx) {
        const base = idx * 9;
        const x0 = rayTriangleData[base], y0 = rayTriangleData[base+1], z0 = rayTriangleData[base+2];
        const x1 = rayTriangleData[base+3], y1 = rayTriangleData[base+4], z1 = rayTriangleData[base+5];
        const x2 = rayTriangleData[base+6], y2 = rayTriangleData[base+7], z2 = rayTriangleData[base+8];
        return {
            minX: Math.min(x0, Math.min(x1, x2)), minY: Math.min(y0, Math.min(y1, y2)), minZ: Math.min(z0, Math.min(z1, z2)),
            maxX: Math.max(x0, Math.max(x1, x2)), maxY: Math.max(y0, Math.max(y1, y2)), maxZ: Math.max(z0, Math.max(z1, z2)),
            cx: (x0+x1+x2)/3, cy: (y0+y1+y2)/3, cz: (z0+z1+z2)/3
        };
    }

    function build(indices) {
        const nodeIndex = nodes.length;
        const node = { min: null, max: null, left: -1, right: -1, offset: -1, count: 0 };
        nodes.push(node);

        const count = indices.length;
        let minX=Infinity, minY=Infinity, minZ=Infinity;
        let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
        let cMinX=Infinity, cMinY=Infinity, cMinZ=Infinity;
        let cMaxX=-Infinity, cMaxY=-Infinity, cMaxZ=-Infinity;

        for(let i=0; i<count; i++) {
            const bounds = getTriangleBounds(indices[i]);
            if(bounds.minX < minX) minX = bounds.minX; if(bounds.maxX > maxX) maxX = bounds.maxX;
            if(bounds.minY < minY) minY = bounds.minY; if(bounds.maxY > maxY) maxY = bounds.maxY;
            if(bounds.minZ < minZ) minZ = bounds.minZ; if(bounds.maxZ > maxZ) maxZ = bounds.maxZ;
            
            if(bounds.cx < cMinX) cMinX = bounds.cx; if(bounds.cx > cMaxX) cMaxX = bounds.cx;
            if(bounds.cy < cMinY) cMinY = bounds.cy; if(bounds.cy > cMaxY) cMaxY = bounds.cy;
            if(bounds.cz < cMinZ) cMinZ = bounds.cz; if(bounds.cz > cMaxZ) cMaxZ = bounds.cz;
        }

        node.min = {x: minX, y: minY, z: minZ};
        node.max = {x: maxX, y: maxY, z: maxZ};

        if (count <= 4) {
            node.offset = rayBVHIndices.length;
            node.count = count;
            for(let i=0; i<count; i++) rayBVHIndices.push(indices[i]);
            return nodeIndex;
        }

        let bestAxis = -1;
        let bestSplitPos = 0;
        let bestCost = Infinity;

        for(let axis=0; axis<3; axis++) {
            let boundsMin, boundsMax, binSize;
            if (axis===0) { boundsMin = cMinX; boundsMax = cMaxX; }
            else if (axis===1) { boundsMin = cMinY; boundsMax = cMaxY; }
            else { boundsMin = cMinZ; boundsMax = cMaxZ; }

            if (boundsMax - boundsMin < 0.0001) continue; 
            binSize = (boundsMax - boundsMin) / BINS;

            const bins = [];
            for(let b=0; b<BINS; b++) bins.push({ count:0, bMinX:Infinity, bMinY:Infinity, bMinZ:Infinity, bMaxX:-Infinity, bMaxY:-Infinity, bMaxZ:-Infinity });

            for(let i=0; i<count; i++) {
                const bds = getTriangleBounds(indices[i]);
                const cVal = (axis===0)?bds.cx : (axis===1)?bds.cy : bds.cz;
                let binIdx = Math.floor((cVal - boundsMin) / binSize);
                if (binIdx >= BINS) binIdx = BINS - 1;
                if (binIdx < 0) binIdx = 0;
                
                const b = bins[binIdx];
                b.count++;
                if(bds.minX < b.bMinX) b.bMinX = bds.minX; if(bds.maxX > b.bMaxX) b.bMaxX = bds.maxX;
                if(bds.minY < b.bMinY) b.bMinY = bds.minY; if(bds.maxY > b.bMaxY) b.bMaxY = bds.maxY;
                if(bds.minZ < b.bMinZ) b.bMinZ = bds.minZ; if(bds.maxZ > b.bMaxZ) b.bMaxZ = bds.maxZ;
            }

            const leftArea = new Float32Array(BINS-1);
            const leftCount = new Uint32Array(BINS-1);
            let accCount = 0;
            let accMinX=Infinity, accMinY=Infinity, accMinZ=Infinity;
            let accMaxX=-Infinity, accMaxY=-Infinity, accMaxZ=-Infinity;

            for(let i=0; i < BINS-1; i++) {
                const b = bins[i];
                accCount += b.count;
                if (b.count > 0) {
                    if(b.bMinX < accMinX) accMinX = b.bMinX; if(b.bMaxX > accMaxX) accMaxX = b.bMaxX;
                    if(b.bMinY < accMinY) accMinY = b.bMinY; if(b.bMaxY > accMaxY) accMaxY = b.bMaxY;
                    if(b.bMinZ < accMinZ) accMinZ = b.bMinZ; if(b.bMaxZ > accMaxZ) accMaxZ = b.bMaxZ;
                }
                leftCount[i] = accCount;
                if (accCount > 0) {
                    leftArea[i] = (accMaxX-accMinX)*(accMaxY-accMinY) + (accMaxY-accMinY)*(accMaxZ-accMinZ) + (accMaxZ-accMinZ)*(accMaxX-accMinX);
                } else leftArea[i] = 0;
            }

            accCount = 0;
            accMinX=Infinity; accMinY=Infinity; accMinZ=Infinity;
            accMaxX=-Infinity; accMaxY=-Infinity; accMaxZ=-Infinity;

            for(let i = BINS-1; i > 0; i--) {
                const b = bins[i];
                accCount += b.count;
                if (b.count > 0) {
                    if(b.bMinX < accMinX) accMinX = b.bMinX; if(b.bMaxX > accMaxX) accMaxX = b.bMaxX;
                    if(b.bMinY < accMinY) accMinY = b.bMinY; if(b.bMaxY > accMaxY) accMaxY = b.bMaxY;
                    if(b.bMinZ < accMinZ) accMinZ = b.bMinZ; if(b.bMaxZ > accMaxZ) accMaxZ = b.bMaxZ;
                }
                
                const lCount = leftCount[i-1];
                const rCount = accCount;
                if (lCount > 0 && rCount > 0) {
                    let rArea = 0;
                    if (rCount > 0) {
                        rArea = (accMaxX-accMinX)*(accMaxY-accMinY) + (accMaxY-accMinY)*(accMaxZ-accMinZ) + (accMaxZ-accMinZ)*(accMaxX-accMinX);
                    }
                    const cost = lCount * leftArea[i-1] + rCount * rArea;
                    if (cost < bestCost) {
                        bestCost = cost;
                        bestAxis = axis;
                        bestSplitPos = boundsMin + i * binSize;
                    }
                }
            }
        }

        if (bestAxis === -1) {
            node.offset = rayBVHIndices.length;
            node.count = count;
            for(let i=0; i<count; i++) rayBVHIndices.push(indices[i]);
            return nodeIndex;
        }

        const leftIndices = [];
        const rightIndices = [];
        for(let i=0; i<count; i++) {
            const bds = getTriangleBounds(indices[i]);
            const val = (bestAxis===0)?bds.cx : (bestAxis===1)?bds.cy : bds.cz;
            if (val < bestSplitPos) leftIndices.push(indices[i]);
            else rightIndices.push(indices[i]);
        }

        if (leftIndices.length === 0 || rightIndices.length === 0) {
            node.offset = rayBVHIndices.length;
            node.count = count;
            for(let i=0; i<count; i++) rayBVHIndices.push(indices[i]);
            return nodeIndex;
        }

        node.left = build(leftIndices);
        node.right = build(rightIndices);
        return nodeIndex;
    }

    rayBVHIndices = []; 
    build(triangleIndices);
    const nodeCount = nodes.length;
    rayBVHBounds = new Float32Array(nodeCount * BVH_NODE_SIZE);
    rayBVHContents = new Uint32Array(nodeCount * BVH_CONTENT_SIZE);
    for(let i=0; i<nodeCount; i++) {
        const n = nodes[i];
        rayBVHBounds[i*6+0] = n.min.x; rayBVHBounds[i*6+1] = n.min.y; rayBVHBounds[i*6+2] = n.min.z;
        rayBVHBounds[i*6+3] = n.max.x; rayBVHBounds[i*6+4] = n.max.y; rayBVHBounds[i*6+5] = n.max.z;
        if (n.count > 0) {
            rayBVHContents[i*2+0] = n.offset; rayBVHContents[i*2+1] = n.count | 0x80000000;
        } else {
            rayBVHContents[i*2+0] = n.left; rayBVHContents[i*2+1] = n.right;
        }
    }
    return { bounds: rayBVHBounds, contents: rayBVHContents, indices: new Uint32Array(rayBVHIndices) };
}

function rayConvertThreeObjects(selectableObjects) {
    const lights = [];
    const emissiveTriangles = []; 
    const progressDiv = document.getElementById('progresso');
    rayTextureList = [];
    if (progressDiv) progressDiv.innerHTML = 'counting triangles...';
    
    if (window.ray_lights && window.ray_lights.length > 0) {
        window.ray_lights.forEach(rayLightInstance => {
            if (rayLightInstance.object) rayLightInstance.object.updateMatrixWorld(true);
            let px = rayLightInstance.position.x;
            let py = rayLightInstance.position.y;
            let pz = rayLightInstance.position.z;
            if (rayLightInstance.object) {
                const mw = rayLightInstance.object.matrixWorld.elements;
                px = mw[12]; py = mw[13]; pz = mw[14];
            }
            lights.push({
                position: { x: px, y: py, z: pz },
                color: [rayLightInstance.color.r, rayLightInstance.color.g, rayLightInstance.color.b],
                intensity: rayLightInstance.intensity,
                radius: rayLightInstance.shadowSoftness,
                castShadow: rayLightInstance.castShadow
            });
        });
    }

    rayTotalTriangles = rayCountTrianglesRecursive(selectableObjects);
    if (rayTotalTriangles === 0) { console.error("Nenhum triângulo encontrado!"); return null; }

    rayTriangleData = new Float32Array(rayTotalTriangles * 9); 
    rayNormalData = new Float32Array(rayTotalTriangles * 9);
    rayUVData = new Float32Array(rayTotalTriangles * 6);
    rayMaterialData = new Float32Array(rayTotalTriangles * 11);
    
    if (progressDiv) progressDiv.innerHTML = 'extracting data...';
    const cursor = { index: 0 };
    rayFillBuffersRecursive(selectableObjects, cursor, emissiveTriangles);
    
    rayEmissiveCount = emissiveTriangles.length;
    rayEmissiveTrianglesData = new Float32Array(rayEmissiveCount * 12);
    for(let i=0; i<rayEmissiveCount; i++) {
        const et = emissiveTriangles[i];
        const base = i * 12;
        rayEmissiveTrianglesData[base] = et.v0.x; rayEmissiveTrianglesData[base+1] = et.v0.y; rayEmissiveTrianglesData[base+2] = et.v0.z;
        rayEmissiveTrianglesData[base+3] = et.v1.x; rayEmissiveTrianglesData[base+4] = et.v1.y; rayEmissiveTrianglesData[base+5] = et.v1.z;
        rayEmissiveTrianglesData[base+6] = et.v2.x; rayEmissiveTrianglesData[base+7] = et.v2.y; rayEmissiveTrianglesData[base+8] = et.v2.z;
        rayEmissiveTrianglesData[base+9] = et.emission.r; rayEmissiveTrianglesData[base+10] = et.emission.g; rayEmissiveTrianglesData[base+11] = et.emission.b;
    }
    console.log(`Ray Tracer: ${rayEmissiveCount} mesh lights identified.`);
    
    if (progressDiv) progressDiv.innerHTML = 'building SAH BVH...';
    const allIndices = new Array(cursor.index);
    for(let i=0; i<cursor.index; i++) allIndices[i] = i;
    
    const bvhData = rayBuildFlatBVH(allIndices);
    return {
        bvhBounds: bvhData.bounds, bvhContents: bvhData.contents, bvhIndices: bvhData.indices,
        lights: lights, triangleData: rayTriangleData, normalData: rayNormalData, uvData: rayUVData,
        materialData: rayMaterialData, textureList: rayTextureList,
        emissiveTrianglesData: rayEmissiveTrianglesData 
    };
}

// --- WORKER: COSINE SAMPLING + FAST MATH + DOF + NEE ---
function rayCreateWorkers() {
    const workerCode = `
// WORKER - Ultimate Optimization

let bvhBounds = null; let bvhContents = null; let bvhIndices = null;
let triangleData = null; let normalData = null; let uvData = null; let materialData = null;
let textureList = null; let sceneLights = null; let camera = null; let config = null;
let skyboxData = null; let skyboxWidth = 0; let skyboxHeight = 0; let useSkybox = false;
let emissiveTrianglesData = null; let emissiveCount = 0;

const stack = new Uint32Array(64);

// --- FAST MATH HELPERS ---
function vec3_dot(ax, ay, az, bx, by, bz) { return ax*bx + ay*by + az*bz; }
function vec3_cross(ax, ay, az, bx, by, bz) { return { x: ay*bz - az*by, y: az*bx - ax*bz, z: ax*by - ay*bx }; }

// Otimização: Sem loops "do...while" (Faster)
function random_in_unit_sphere() {
    const u = Math.random(); const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    const r = Math.cbrt(Math.random());
    const sinPhi = Math.sin(phi);
    return { x: r * sinPhi * Math.cos(theta), y: r * sinPhi * Math.sin(theta), z: r * Math.cos(phi) };
}

function random_unit_vector() {
    const u = Math.random();
    const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    const sinPhi = Math.sin(phi);
    return { x: sinPhi * Math.cos(theta), y: sinPhi * Math.sin(theta), z: Math.cos(phi) };
}

// Otimização: Cosine Weighted Sampling
function random_cosine_direction() {
    const r1 = Math.random();
    const r2 = Math.random();
    const z = Math.sqrt(1 - r2);
    const phi = 2 * Math.PI * r1;
    const x = Math.cos(phi) * Math.sqrt(r2);
    const y = Math.sin(phi) * Math.sqrt(r2);
    return { x, y, z };
}

function build_onb(nx, ny, nz) {
    let ax = (Math.abs(nx) > 0.9) ? 0 : 1;
    let ay = (Math.abs(nx) > 0.9) ? 1 : 0;
    let az = 0;
    let ux = ay * nz - az * ny; let uy = az * nx - ax * nz; let uz = ax * ny - ay * nx;
    let len = Math.sqrt(ux*ux + uy*uy + uz*uz); ux/=len; uy/=len; uz/=len;
    let vx = ny * uz - nz * uy; let vy = nz * ux - nx * uz; let vz = nx * uy - ny * ux;
    return { ux, uy, uz, vx, vy, vz };
}

function random_in_unit_disk() {
    const r = Math.sqrt(Math.random());
    const theta = 2 * Math.PI * Math.random();
    return { x: r * Math.cos(theta), y: r * Math.sin(theta) };
}

function reflect(vx, vy, vz, nx, ny, nz) {
    const dt = vx*nx + vy*ny + vz*nz; return { x: vx - 2*dt*nx, y: vy - 2*dt*ny, z: vz - 2*dt*nz };
}

function refract(uvx, uvy, uvz, nx, ny, nz, etai_over_etat) {
    const cos_theta = Math.min(vec3_dot(-uvx, -uvy, -uvz, nx, ny, nz), 1.0);
    const r_out_perp_x = etai_over_etat * (uvx + cos_theta * nx);
    const r_out_perp_y = etai_over_etat * (uvy + cos_theta * ny);
    const r_out_perp_z = etai_over_etat * (uvz + cos_theta * nz);
    const r_out_parallel_sq = r_out_perp_x*r_out_perp_x + r_out_perp_y*r_out_perp_y + r_out_perp_z*r_out_perp_z;
    if (Math.abs(1.0 - r_out_parallel_sq) < 0.0) return {x:0,y:0,z:0}; 
    const r_out_parallel_abs = Math.sqrt(Math.abs(1.0 - r_out_parallel_sq));
    return { x: r_out_perp_x - r_out_parallel_abs * nx, y: r_out_perp_y - r_out_parallel_abs * ny, z: r_out_perp_z - r_out_parallel_abs * nz };
}

function schlickFull(cosine, f0) {
    return f0 + (1.0 - f0) * Math.pow((1.0 - cosine), 5);
}

function sampleTexture(texId, u, v) {
    const tex = textureList[texId]; if(!tex) return [1,0,1]; 
    let tx = u - Math.floor(u); let ty = v - Math.floor(v); ty = 1.0 - ty; 
    const w = tex.width; const h = tex.height;
    const x = tx*(w-1); const y = ty*(h-1);
    const x0 = Math.floor(x); const y0 = Math.floor(y); const x1 = Math.min(x0+1, w-1); const y1 = Math.min(y0+1, h-1);
    const fx = x-x0; const fy = y-y0;
    const idx00=(y0*w+x0)*4; const idx10=(y0*w+x1)*4; const idx01=(y1*w+x0)*4; const idx11=(y1*w+x1)*4;
    const r = (1-fx)*(1-fy)*tex.data[idx00] + fx*(1-fy)*tex.data[idx10] + (1-fx)*fy*tex.data[idx01] + fx*fy*tex.data[idx11];
    const g = (1-fx)*(1-fy)*tex.data[idx00+1] + fx*(1-fy)*tex.data[idx10+1] + (1-fx)*fy*tex.data[idx01+1] + fx*fy*tex.data[idx11+1];
    const b = (1-fx)*(1-fy)*tex.data[idx00+2] + fx*(1-fy)*tex.data[idx10+2] + (1-fx)*fy*tex.data[idx01+2] + fx*fy*tex.data[idx11+2];
    return [r, g, b];
}

function sampleSkybox(dx, dy, dz) {
    if (!useSkybox || !skyboxData) return [config.backgroundColor[0], config.backgroundColor[1], config.backgroundColor[2]];
    const theta = Math.atan2(dx, dz); const phi = Math.asin(Math.max(-1, Math.min(1, dy)));
    const u = 0.5 + theta / (2 * Math.PI); const v = 0.5 - phi / Math.PI;
    const x = u*(skyboxWidth-1); const y = v*(skyboxHeight-1);
    const x0 = Math.floor(x); const y0 = Math.floor(y); const x1 = Math.min(x0+1, skyboxWidth-1); const y1 = Math.min(y0+1, skyboxHeight-1);
    const fx = x-x0; const fy = y-y0;
    const idx00=(y0*skyboxWidth+x0)*4; const idx10=(y0*skyboxWidth+x1)*4; const idx01=(y1*skyboxWidth+x0)*4; const idx11=(y1*skyboxWidth+x1)*4;
    const r = (1-fx)*(1-fy)*skyboxData[idx00] + fx*(1-fy)*skyboxData[idx10] + (1-fx)*fy*skyboxData[idx01] + fx*fy*skyboxData[idx11];
    const g = (1-fx)*(1-fy)*skyboxData[idx00+1] + fx*(1-fy)*skyboxData[idx10+1] + (1-fx)*fy*skyboxData[idx01+1] + fx*fy*skyboxData[idx11+1];
    const b = (1-fx)*(1-fy)*skyboxData[idx00+2] + fx*(1-fy)*skyboxData[idx10+2] + (1-fx)*fy*skyboxData[idx01+2] + fx*fy*skyboxData[idx11+2];
    return [r, g, b];
}

function intersectTriangle(rox, roy, roz, rdx, rdy, rdz, triIndex, tMax) {
    const base = triIndex * 9;
    const v0x = triangleData[base]; const v0y = triangleData[base+1]; const v0z = triangleData[base+2];
    const v1x = triangleData[base+3]; const v1y = triangleData[base+4]; const v1z = triangleData[base+5];
    const v2x = triangleData[base+6]; const v2y = triangleData[base+7]; const v2z = triangleData[base+8];
    const e1x = v1x - v0x; const e1y = v1y - v0y; const e1z = v1z - v0z;
    const e2x = v2x - v0x; const e2y = v2y - v0y; const e2z = v2z - v0z;
    const hx = rdy * e2z - rdz * e2y; const hy = rdz * e2x - rdx * e2z; const hz = rdx * e2y - rdy * e2x;
    const a = e1x * hx + e1y * hy + e1z * hz;
    if (a > -0.0000001 && a < 0.0000001) return null;
    const f = 1.0 / a;
    const sx = rox - v0x; const sy = roy - v0y; const sz = roz - v0z;
    const u = f * (sx * hx + sy * hy + sz * hz);
    if (u < 0.0 || u > 1.0) return null;
    const qx = sy * e1z - sz * e1y; const qy = sz * e1x - sx * e1z; const qz = sx * e1y - sy * e1x;
    const v = f * (rdx * qx + rdy * qy + rdz * qz);
    if (v < 0.0 || u + v > 1.0) return null;
    const t = f * (e2x * qx + e2y * qy + e2z * qz);
    if (t > 0.0000001 && t < tMax) return { t: t, u: u, v: v };
    return null;
}
function intersectAABB(rox, roy, roz, rinvDx, rinvDy, rinvDz, nodeIdx, tMax) {
    const base = nodeIdx * 6;
    let t0 = (bvhBounds[base] - rox) * rinvDx; let t1 = (bvhBounds[base+3] - rox) * rinvDx;
    if (rinvDx < 0.0) { let s = t0; t0 = t1; t1 = s; }
    let tmin = t0; let tmax = t1;
    t0 = (bvhBounds[base+1] - roy) * rinvDy; t1 = (bvhBounds[base+4] - roy) * rinvDy;
    if (rinvDy < 0.0) { let s = t0; t0 = t1; t1 = s; }
    if ((t0 > tmax) || (tmin > t1)) return false;
    if (t0 > tmin) tmin = t0; if (t1 < tmax) tmax = t1;
    t0 = (bvhBounds[base+2] - roz) * rinvDz; t1 = (bvhBounds[base+5] - roz) * rinvDz;
    if (rinvDz < 0.0) { let s = t0; t0 = t1; t1 = s; }
    if ((t0 > tmax) || (tmin > t1)) return false;
    return tmin < tMax && tmax > 0.0;
}
function intersectScene(rox, roy, roz, rdx, rdy, rdz, tMax) {
    const rinvDx = 1.0 / rdx; const rinvDy = 1.0 / rdy; const rinvDz = 1.0 / rdz;
    let closestHit = { hit: false, distance: tMax, index: -1, u: 0, v: 0 };
    let stackPtr = 0; stack[stackPtr++] = 0;
    while (stackPtr > 0) {
        const nodeIdx = stack[--stackPtr];
        if (!intersectAABB(rox, roy, roz, rinvDx, rinvDy, rinvDz, nodeIdx, closestHit.distance)) continue;
        const contentData1 = bvhContents[nodeIdx * 2]; const contentData2 = bvhContents[nodeIdx * 2 + 1];
        const isLeaf = (contentData2 & 0x80000000) !== 0;
        if (isLeaf) {
            const count = contentData2 & 0x7FFFFFFF; const offset = contentData1;
            for(let i = 0; i < count; i++) {
                const triIdx = bvhIndices[offset + i];
                const hitResult = intersectTriangle(rox, roy, roz, rdx, rdy, rdz, triIdx, closestHit.distance);
                if (hitResult !== null) {
                    closestHit.distance = hitResult.t; closestHit.u = hitResult.u; closestHit.v = hitResult.v;
                    closestHit.hit = true; closestHit.index = triIdx;
                }
            }
        } else { stack[stackPtr++] = contentData2; stack[stackPtr++] = contentData1; }
    }
    if (closestHit.hit) {
         const idx = closestHit.index; 
         const nBase = idx * 9;
         const n0x = normalData[nBase], n0y = normalData[nBase+1], n0z = normalData[nBase+2];
         const n1x = normalData[nBase+3], n1y = normalData[nBase+4], n1z = normalData[nBase+5];
         const n2x = normalData[nBase+6], n2y = normalData[nBase+7], n2z = normalData[nBase+8];
         
         const w = 1.0 - closestHit.u - closestHit.v;
         let nx = w * n0x + closestHit.u * n1x + closestHit.v * n2x;
         let ny = w * n0y + closestHit.u * n1y + closestHit.v * n2y;
         let nz = w * n0z + closestHit.u * n1z + closestHit.v * n2z;
         const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
         
         const uvBase = idx * 6;
         const u0 = uvData[uvBase], v0 = uvData[uvBase+1];
         const u1 = uvData[uvBase+2], v1 = uvData[uvBase+3];
         const u2 = uvData[uvBase+4], v2 = uvData[uvBase+5];
         const finalU = w * u0 + closestHit.u * u1 + closestHit.v * u2;
         const finalV = w * v0 + closestHit.u * v1 + closestHit.v * v2;
         const mBase = idx * 11;
         
         closestHit.point = { x: rox + rdx * closestHit.distance, y: roy + rdy * closestHit.distance, z: roz + rdz * closestHit.distance };
         closestHit.normal = { x: nx/len, y: ny/len, z: nz/len };
         closestHit.uv = { u: finalU, v: finalV };
         closestHit.material = {
             color: [materialData[mBase], materialData[mBase+1], materialData[mBase+2]],
             roughness: materialData[mBase+3], 
             emissive: [materialData[mBase+5], materialData[mBase+6], materialData[mBase+7]],
             metalness: materialData[mBase+8], 
             transmission: materialData[mBase+9], 
             textureId: materialData[mBase+10]
         };
    }
    return closestHit;
}

function computeAO(px, py, pz, nx, ny, nz) {
    if (!config.aoEnabled) return 1.0;
    let occlusion = 0.0; const samples = config.aoSamples; const radius = config.aoRadius; const intensity = config.aoIntensity;
    for(let i=0; i<samples; i++) {
        // Fast random unit vector
        const u = Math.random(); const v = Math.random();
        const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
        const sinPhi = Math.sin(phi);
        let dx = sinPhi * Math.cos(theta); let dy = sinPhi * Math.sin(theta); let dz = Math.cos(phi);
        
        if (vec3_dot(dx, dy, dz, nx, ny, nz) < 0) { dx = -dx; dy = -dy; dz = -dz; }
        const hit = intersectScene(px + nx * 0.001, py + ny * 0.001, pz + nz * 0.001, dx, dy, dz, radius);
        if (hit.hit) occlusion += 1.0;
    }
    return 1.0 - ((occlusion / samples) * intensity);
}

function pathTraceIterative(camX, camY, camZ, rdx, rdy, rdz) {
    let throughput = [1, 1, 1]; let accumulatedLight = [0, 0, 0];
    let curX = camX, curY = camY, curZ = camZ; let curDx = rdx, curDy = rdy, curDz = rdz;
    let firstHitNormal = {x:0, y:0, z:0};
    let firstHitDepth = -1.0;

    for (let depth = 0; depth < config.maxBounces; depth++) {
        const hit = intersectScene(curX, curY, curZ, curDx, curDy, curDz, Infinity);
        
        if (depth === 0) {
            if (hit.hit) { firstHitNormal = hit.normal; firstHitDepth = hit.distance; } 
            else { firstHitDepth = 10000.0; }
        }

        if (!hit.hit) {
            const skyColor = sampleSkybox(curDx, curDy, curDz);
            let skyR = throughput[0] * skyColor[0];
            let skyG = throughput[1] * skyColor[1];
            let skyB = throughput[2] * skyColor[2];
            if (depth > 0) {
                const maxSkyBrightness = 2.0; 
                skyR = Math.min(skyR, maxSkyBrightness);
                skyG = Math.min(skyG, maxSkyBrightness);
                skyB = Math.min(skyB, maxSkyBrightness);
            }
            accumulatedLight[0] += skyR; accumulatedLight[1] += skyG; accumulatedLight[2] += skyB;
            break;
        }

        if (hit.material.textureId >= 0) {
             const texColor = sampleTexture(hit.material.textureId, hit.uv.u, hit.uv.v);
             hit.material.color[0] *= texColor[0]; hit.material.color[1] *= texColor[1]; hit.material.color[2] *= texColor[2];
        }
        
        if (depth === 0 && config.aoEnabled) {
            const aoFactor = computeAO(hit.point.x, hit.point.y, hit.point.z, hit.normal.x, hit.normal.y, hit.normal.z);
            throughput[0] *= aoFactor; throughput[1] *= aoFactor; throughput[2] *= aoFactor;
        }

        let emR = hit.material.emissive[0]; let emG = hit.material.emissive[1]; let emB = hit.material.emissive[2];
        if (depth > 0) {
             const maxIndirect = 0.5;
             const currentEm = Math.max(emR, Math.max(emG, emB));
             if (currentEm > maxIndirect) {
                 const scale = maxIndirect / currentEm;
                 emR *= scale; emG *= scale; emB *= scale;
             }
        }
        accumulatedLight[0] += throughput[0] * emR; accumulatedLight[1] += throughput[1] * emG; accumulatedLight[2] += throughput[2] * emB;

        let scatterDir = {x:0, y:0, z:0};
        
        // 1. METAL
        if (Math.random() < hit.material.metalness) {
             const reflected = reflect(curDx, curDy, curDz, hit.normal.x, hit.normal.y, hit.normal.z);
             const u = Math.random(); const v = Math.random(); const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1); const r = Math.cbrt(Math.random()); const sinPhi = Math.sin(phi);
             const fuzz = { x: r * sinPhi * Math.cos(theta), y: r * sinPhi * Math.sin(theta), z: r * Math.cos(phi) };
             
             scatterDir.x = reflected.x + fuzz.x * hit.material.roughness;
             scatterDir.y = reflected.y + fuzz.y * hit.material.roughness;
             scatterDir.z = reflected.z + fuzz.z * hit.material.roughness;
             if (vec3_dot(scatterDir.x, scatterDir.y, scatterDir.z, hit.normal.x, hit.normal.y, hit.normal.z) <= 0) break; 
             throughput[0] *= hit.material.color[0]; throughput[1] *= hit.material.color[1]; throughput[2] *= hit.material.color[2];

        // 2. DIELECTRIC / DIFFUSE
        } else {
             const F0 = 0.04; 
             let cosine = -vec3_dot(curDx, curDy, curDz, hit.normal.x, hit.normal.y, hit.normal.z);
             if (cosine < 0) cosine = -cosine; 
             const fresnelReflectance = schlickFull(cosine, F0);
             
             if (Math.random() < fresnelReflectance) {
                  const reflected = reflect(curDx, curDy, curDz, hit.normal.x, hit.normal.y, hit.normal.z);
                  const u = Math.random(); const v = Math.random(); const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1); const r = Math.cbrt(Math.random()); const sinPhi = Math.sin(phi);
                  const fuzz = { x: r * sinPhi * Math.cos(theta), y: r * sinPhi * Math.sin(theta), z: r * Math.cos(phi) };
                  scatterDir.x = reflected.x + fuzz.x * hit.material.roughness;
                  scatterDir.y = reflected.y + fuzz.y * hit.material.roughness;
                  scatterDir.z = reflected.z + fuzz.z * hit.material.roughness;
                  if (vec3_dot(scatterDir.x, scatterDir.y, scatterDir.z, hit.normal.x, hit.normal.y, hit.normal.z) <= 0) {
                      const rand = random_unit_vector();
                      scatterDir = { x: hit.normal.x + rand.x, y: hit.normal.y + rand.y, z: hit.normal.z + rand.z };
                  }
             } else {
                  if (Math.random() < hit.material.transmission) {
                    const refIdx = 1.5;
                    let etai_over_etat = 1.0 / refIdx;
                    let normal = hit.normal;
                    const dot = vec3_dot(curDx, curDy, curDz, normal.x, normal.y, normal.z);
                    if (dot > 0) { normal = {x: -normal.x, y: -normal.y, z: -normal.z}; etai_over_etat = refIdx; }
                    scatterDir = refract(curDx, curDy, curDz, normal.x, normal.y, normal.z, etai_over_etat);
                    throughput[0] *= hit.material.color[0]; throughput[1] *= hit.material.color[1]; throughput[2] *= hit.material.color[2];
                  } else {
                    // --- COSINE WEIGHTED SAMPLING (IMPORTANCE SAMPLING) ---
                    const onb = build_onb(hit.normal.x, hit.normal.y, hit.normal.z);
                    const local = random_cosine_direction();
                    scatterDir = {
                        x: local.x * onb.ux + local.y * onb.vx + local.z * hit.normal.x,
                        y: local.x * onb.uy + local.y * onb.vy + local.z * hit.normal.y,
                        z: local.x * onb.uz + local.y * onb.vz + local.z * hit.normal.z
                    };
                    // Note: PDF cancels cosine term. Throughput is just Albedo.

                    // --- NEE (Mesh Lights) ---
                    if (emissiveCount > 0) {
                        const lightIdx = Math.floor(Math.random() * emissiveCount);
                        const base = lightIdx * 12;
                        const v0 = {x:emissiveTrianglesData[base], y:emissiveTrianglesData[base+1], z:emissiveTrianglesData[base+2]};
                        const v1 = {x:emissiveTrianglesData[base+3], y:emissiveTrianglesData[base+4], z:emissiveTrianglesData[base+5]};
                        const v2 = {x:emissiveTrianglesData[base+6], y:emissiveTrianglesData[base+7], z:emissiveTrianglesData[base+8]};
                        const emission = {r:emissiveTrianglesData[base+9], g:emissiveTrianglesData[base+10], b:emissiveTrianglesData[base+11]};

                        const r1 = Math.random(); const r2 = Math.random();
                        const sqr1 = Math.sqrt(r1); const u = 1 - sqr1; const v = r2 * sqr1; const w = 1 - u - v; 
                        const lx = w*v0.x + u*v1.x + v*v2.x; const ly = w*v0.y + u*v1.y + v*v2.y; const lz = w*v0.z + u*v1.z + v*v2.z;

                        let ldx = lx - hit.point.x; let ldy = ly - hit.point.y; let ldz = lz - hit.point.z;
                        const distSq = ldx*ldx + ldy*ldy + ldz*ldz; const dist = Math.sqrt(distSq); ldx /= dist; ldy /= dist; ldz /= dist;

                        const cosTheta = hit.normal.x * ldx + hit.normal.y * ldy + hit.normal.z * ldz;
                        if (cosTheta > 0) {
                            const e1 = {x:v1.x-v0.x, y:v1.y-v0.y, z:v1.z-v0.z};
                            const e2 = {x:v2.x-v0.x, y:v2.y-v0.y, z:v2.z-v0.z};
                            const ln = vec3_cross(e1.x, e1.y, e1.z, e2.x, e2.y, e2.z);
                            const area2 = Math.sqrt(ln.x*ln.x + ln.y*ln.y + ln.z*ln.z);
                            const area = area2 * 0.5;
                            const lnx = ln.x/area2; const lny = ln.y/area2; const lnz = ln.z/area2;
                            const cosLight = -(ldx*lnx + ldy*lny + ldz*lnz);
                            if (cosLight > 0) {
                                const shadowHit = intersectScene(hit.point.x + hit.normal.x*0.001, hit.point.y + hit.normal.y*0.001, hit.point.z + hit.normal.z*0.001, ldx, ldy, ldz, dist - 0.01);
                                if (!shadowHit.hit) {
                                    const geometryFactor = (cosTheta * cosLight * area) / distSq;
                                    const weight = geometryFactor * emissiveCount; 
                                    let directR = throughput[0] * hit.material.color[0] * emission.r * weight * (1/Math.PI);
                                    let directG = throughput[1] * hit.material.color[1] * emission.g * weight * (1/Math.PI);
                                    let directB = throughput[2] * hit.material.color[2] * emission.b * weight * (1/Math.PI);
                                    const maxNEE = 4.0;
                                    directR = Math.min(directR, maxNEE); directG = Math.min(directG, maxNEE); directB = Math.min(directB, maxNEE);
                                    accumulatedLight[0] += directR; accumulatedLight[1] += directG; accumulatedLight[2] += directB;
                                }
                            }
                        }
                    }

                    // --- POINT LIGHTS NEE ---
                    for(let i=0; i<sceneLights.length; i++) {
                        const light = sceneLights[i];
                        let lx = light.position.x; let ly = light.position.y; let lz = light.position.z;
                        if (light.radius > 0.0) {
                             const u = Math.random(); const v = Math.random(); const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1); const r = Math.cbrt(Math.random()); const sinPhi = Math.sin(phi);
                             const rnd = { x: r * sinPhi * Math.cos(theta), y: r * sinPhi * Math.sin(theta), z: r * Math.cos(phi) };
                             lx += rnd.x * light.radius; ly += rnd.y * light.radius; lz += rnd.z * light.radius;
                        }
                        let ldx = lx - hit.point.x; let ldy = ly - hit.point.y; let ldz = lz - hit.point.z;
                        const distSq = ldx*ldx + ldy*ldy + ldz*ldz; const dist = Math.sqrt(distSq); ldx /= dist; ldy /= dist; ldz /= dist;
                        const cosTheta = hit.normal.x * ldx + hit.normal.y * ldy + hit.normal.z * ldz;
                        if (cosTheta > 0) {
                            let inShadow = false;
                            if (light.castShadow !== false) {
                                const shadowHit = intersectScene(hit.point.x + hit.normal.x * 0.001, hit.point.y + hit.normal.y * 0.001, hit.point.z + hit.normal.z * 0.001, ldx, ldy, ldz, dist - 0.01);
                                inShadow = shadowHit.hit;
                            }
                            if (!inShadow) {
                                 const att = light.intensity / distSq; const pdf = 1 / Math.PI; 
                                 let directR = throughput[0] * hit.material.color[0] * pdf * light.color[0] * cosTheta * att;
                                 let directG = throughput[1] * hit.material.color[1] * pdf * light.color[1] * cosTheta * att;
                                 let directB = throughput[2] * hit.material.color[2] * pdf * light.color[2] * cosTheta * att;
                                 directR = Math.min(directR, 10.0); directG = Math.min(directG, 10.0); directB = Math.min(directB, 10.0);
                                 accumulatedLight[0] += directR; accumulatedLight[1] += directG; accumulatedLight[2] += directB;
                            }
                        }
                    }
                    throughput[0] *= hit.material.color[0]; throughput[1] *= hit.material.color[1]; throughput[2] *= hit.material.color[2];
                 }
             }
        }
        if (depth > 3) {
            const p = Math.max(throughput[0], Math.max(throughput[1], throughput[2]));
            if (Math.random() > p) break; 
            throughput[0] /= p; throughput[1] /= p; throughput[2] /= p;
        }
        const len = Math.sqrt(scatterDir.x*scatterDir.x + scatterDir.y*scatterDir.y + scatterDir.z*scatterDir.z);
        curDx = scatterDir.x / len; curDy = scatterDir.y / len; curDz = scatterDir.z / len;
        curX = hit.point.x + curDx * 0.0001; curY = hit.point.y + curDy * 0.0001; curZ = hit.point.z + curDz * 0.0001;
    }
    return { r: accumulatedLight[0], g: accumulatedLight[1], b: accumulatedLight[2], nx: firstHitNormal.x, ny: firstHitNormal.y, nz: firstHitNormal.z, depth: firstHitDepth };
}
self.onmessage = function(e) {
    const { type, data } = e.data;
    if (type === 'init') {
        bvhBounds = data.bvhBounds; bvhContents = data.bvhContents; bvhIndices = data.bvhIndices;
        sceneLights = data.lights; triangleData = data.triangleData; normalData = data.normalData;
        uvData = data.uvData; materialData = data.materialData; textureList = data.textureList; camera = data.camera; config = data.config;
        emissiveTrianglesData = data.emissiveTrianglesData; emissiveCount = emissiveTrianglesData ? emissiveTrianglesData.length / 12 : 0;
        if (data.skyboxData) { skyboxData = data.skyboxData; skyboxWidth = data.skyboxWidth; skyboxHeight = data.skyboxHeight; useSkybox = data.useSkybox; }
        self.postMessage({ type: 'ready' });
    } else if (type === 'renderTile') {
        const { startX, startY, tileW, tileH, width, height } = data;
        const tileData = new Float32Array(tileW * tileH * 8); 
        const camX = camera.position.x; const camY = camera.position.y; const camZ = camera.position.z;
        const aspect = camera.aspect; const fovScale = Math.tan(camera.fov * Math.PI / 180 / 2);
        let fx = camera.target.x - camX; let fy = camera.target.y - camY; let fz = camera.target.z - camZ;
        let len = Math.sqrt(fx*fx + fy*fy + fz*fz); fx/=len; fy/=len; fz/=len;
        let rx = -fz; let ry = 0; let rz = fx; len = Math.sqrt(rx*rx + ry*ry + rz*rz); rx/=len; ry/=len; rz/=len;
        let ux = ry * fz - rz * fy; let uy = rz * fx - rx * fz; let uz = rx * fy - ry * fx; len = Math.sqrt(ux*ux + uy*uy + uz*uz); ux/=len; uy/=len; uz/=len;
        
        let idx = 0;
        const aperture = config.aperture || 0.0;
        const focusDist = config.focusDistance || 10.0;
        
        for (let y = startY; y < startY + tileH; y++) {
            for (let x = startX; x < startX + tileW; x++) {
                const r1 = Math.random() - 0.5; const r2 = Math.random() - 0.5;
                const u = (2 * (x + r1) / width - 1) * aspect * fovScale;
                const v = (1 - 2 * (y + r2) / height) * fovScale;
                let rdx = fx + rx * u + ux * v; let rdy = fy + ry * u + uy * v; let rdz = fz + rz * u + uz * v;
                let rlen = Math.sqrt(rdx*rdx + rdy*rdy + rdz*rdz);
                let dirX = rdx/rlen, dirY = rdy/rlen, dirZ = rdz/rlen;
                let orgX = camX, orgY = camY, orgZ = camZ;
                
                if (aperture > 0.0) {
                    const focusPointX = camX + dirX * focusDist; const focusPointY = camY + dirY * focusDist; const focusPointZ = camZ + dirZ * focusDist;
                    const rdR = Math.sqrt(Math.random()); const rdTheta = 2 * Math.PI * Math.random();
                    const lensRadius = aperture / 2.0;
                    const offsetX = rx * (rdR * Math.cos(rdTheta)) * lensRadius + ux * (rdR * Math.sin(rdTheta)) * lensRadius;
                    const offsetY = ry * (rdR * Math.cos(rdTheta)) * lensRadius + uy * (rdR * Math.sin(rdTheta)) * lensRadius;
                    const offsetZ = rz * (rdR * Math.cos(rdTheta)) * lensRadius + uz * (rdR * Math.sin(rdTheta)) * lensRadius;
                    orgX += offsetX; orgY += offsetY; orgZ += offsetZ;
                    const newDirX = focusPointX - orgX; const newDirY = focusPointY - orgY; const newDirZ = focusPointZ - orgZ;
                    const newLen = Math.sqrt(newDirX*newDirX + newDirY*newDirY + newDirZ*newDirZ);
                    dirX = newDirX/newLen; dirY = newDirY/newLen; dirZ = newDirZ/newLen;
                }
                
                const result = pathTraceIterative(orgX, orgY, orgZ, dirX, dirY, dirZ);
                tileData[idx++] = result.r; tileData[idx++] = result.g; tileData[idx++] = result.b; tileData[idx++] = 1.0; 
                tileData[idx++] = result.nx; tileData[idx++] = result.ny; tileData[idx++] = result.nz; tileData[idx++] = result.depth;
            }
        }
        self.postMessage({ type: 'result', data: { startX, startY, tileW, tileH, tileData } }, [tileData.buffer]);
    }
};
`;
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const workerURL = URL.createObjectURL(blob);
    for (let i = 0; i < rayNumWorkers; i++) rayWorkers.push(new Worker(workerURL));
}

function rayToneMapACES(color) {
    const a = 2.51, b = 0.03, c = 2.43, d = 0.59, e = 0.14;
    return [
        Math.max(0, (color[0] * (a * color[0] + b)) / (color[0] * (c * color[0] + d) + e)),
        Math.max(0, (color[1] * (a * color[1] + b)) / (color[1] * (c * color[1] + d) + e)),
        Math.max(0, (color[2] * (a * color[2] + b)) / (color[2] * (c * color[2] + d) + e))
    ];
}

function rayGammaCorrect(color) {
    const gamma = 2.2;
    return color.map(c => Math.pow(Math.max(0, Math.min(1, c)), 1 / gamma));
}

function rayJointBilateralFilter(width, height, colorBuffer, normalDepthBuffer, sampleCountBuffer) {
    const output = new Float32Array(colorBuffer.length);
    const w = width; const h = height;
    const sigmaSpatial = 4.0; const sigmaColor = 1.0; const kSize = 2; 
    const kernelWeights = [];
    for(let ky=-kSize; ky<=kSize; ky++) {
        for(let kx=-kSize; kx<=kSize; kx++) {
            const distSq = kx*kx + ky*ky;
            const wS = Math.exp(-distSq / (2 * sigmaSpatial * sigmaSpatial));
            kernelWeights.push({ x: kx, y: ky, w: wS });
        }
    }
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const idx = (y * w + x) * 4;
            const s0 = sampleCountBuffer ? sampleCountBuffer[idx] : 1.0;
            const invS0 = 1.0 / (s0 < 1 ? 1 : s0);
            
            const r0 = colorBuffer[idx] * invS0; const g0 = colorBuffer[idx+1] * invS0; const b0 = colorBuffer[idx+2] * invS0;
            const nx0 = normalDepthBuffer[idx]; const ny0 = normalDepthBuffer[idx+1]; const nz0 = normalDepthBuffer[idx+2]; const d0 = normalDepthBuffer[idx+3];
            let sumR = 0, sumG = 0, sumB = 0; let weightSum = 0;
            for (let k = 0; k < kernelWeights.length; k++) {
                const kw = kernelWeights[k];
                const nx = x + kw.x; const ny = y + kw.y;
                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                    const nIdx = (ny * w + nx) * 4;
                    const s1 = sampleCountBuffer ? sampleCountBuffer[nIdx] : 1.0;
                    const invS1 = 1.0 / (s1 < 1 ? 1 : s1);
                    
                    const r1 = colorBuffer[nIdx] * invS1; const g1 = colorBuffer[nIdx+1] * invS1; const b1 = colorBuffer[nIdx+2] * invS1;
                    const dr = r1 - r0; const dg = g1 - g0; const db = b1 - b0;
                    const distColorSq = dr*dr + dg*dg + db*db;
                    const wColor = Math.exp(-distColorSq / (2 * sigmaColor * sigmaColor));
                    const nx1 = normalDepthBuffer[nIdx]; const ny1 = normalDepthBuffer[nIdx+1]; const nz1 = normalDepthBuffer[nIdx+2];
                    let dot = nx0*nx1 + ny0*ny1 + nz0*nz1;
                    const wNormal = Math.pow(Math.max(0, dot), 128 * 0.5); 
                    const d1 = normalDepthBuffer[nIdx+3];
                    const distDepth = Math.abs(d0 - d1);
                    const wDepth = Math.exp(-distDepth / 0.5);
                    const totalWeight = kw.w * wColor * wNormal * wDepth;
                    sumR += r1 * totalWeight; sumG += g1 * totalWeight; sumB += b1 * totalWeight;
                    weightSum += totalWeight;
                }
            }
            if (weightSum > 0) { output[idx] = sumR / weightSum; output[idx+1] = sumG / weightSum; output[idx+2] = sumB / weightSum; output[idx+3] = 1.0; } 
            else { output[idx] = r0; output[idx+1] = g0; output[idx+2] = b0; output[idx+3] = 1.0; }
        }
    }
    return output;
}

function rayProcessNextTile(worker) {
    if (rayTileQueue.length > 0) {
        const tile = rayTileQueue.shift();
        rayActiveWorkersCount++;
        worker.postMessage({ type: 'renderTile', data: tile });
    } else {
        if (rayActiveWorkersCount === 0) rayFinalizePass();
    }
}

function rayFinalizePass() {
    raySamples++;
    const width = rayCanvas.width;
    const height = rayCanvas.height;
    const progressDiv = document.getElementById('progresso');

    let displayBuffer = rayAccumulationBuffer;
    
    if (rayConfig.denoise && raySamples === rayConfig.maxSamples) {
        if (progressDiv) progressDiv.innerHTML = 'Applying Joint Bilateral Denoise...';
        setTimeout(() => {
             // Passamos o buffer de samples para o denoiser calcular a média correta por pixel
             displayBuffer = rayJointBilateralFilter(width, height, rayAccumulationBuffer, rayNormalDepthBuffer, raySampleCountBuffer);
             rayUpdateCanvas(displayBuffer, true); // true = já dividido pelo denoiser
             console.log('Ray Tracer: Complete with Joint Bilateral Denoise!');
             if (progressDiv) progressDiv.innerHTML = 'rendering complete';
             rayIsRendering = false;
             if (rayRenderButton) rayRenderButton.textContent = 'Iniciar Render';
        }, 10);
        return; 
    } 

    rayUpdateCanvas(displayBuffer, false);
    if (progressDiv) progressDiv.innerHTML = `rendering sample ${raySamples}/${rayConfig.maxSamples}`;

    if (raySamples < rayConfig.maxSamples && rayIsRendering) {
        rayGenerateTileQueue();
        rayWorkers.forEach(w => rayProcessNextTile(w));
    } else if (!rayConfig.denoise) {
        console.log('Ray Tracer: Complete!');
        if (progressDiv) progressDiv.innerHTML = 'rendering complete';
        rayIsRendering = false;
        if (rayRenderButton) rayRenderButton.textContent = 'Iniciar Render';
    }
}

function rayUpdateCanvas(buffer, isAlreadyDivided) {
    const width = rayCanvas.width;
    for (let i = 0; i < rayImageData.data.length; i += 4) {
        let r, g, b;
        
        if (isAlreadyDivided) {
            r = buffer[i]; g = buffer[i+1]; b = buffer[i+2];
        } else {
            // CORREÇÃO CRÍTICA: Divide pelo número real de samples que este pixel recebeu
            // Se o pixel convergiu cedo, raySampleCountBuffer[i] será menor que raySamples global.
            // Isso evita que ele fique preto.
            let count = (raySampleCountBuffer && raySampleCountBuffer[i]) ? raySampleCountBuffer[i] : 1;
            if (count < 1) count = 1;
            
            r = buffer[i] / count;
            g = buffer[i+1] / count;
            b = buffer[i+2] / count;
        }

        const avgColor = [r, g, b];
        const toneMapped = rayToneMapACES(avgColor);
        const gammaCorrected = rayGammaCorrect(toneMapped);
        rayImageData.data[i + 0] = gammaCorrected[0] * 255;
        rayImageData.data[i + 1] = gammaCorrected[1] * 255;
        rayImageData.data[i + 2] = gammaCorrected[2] * 255;
        rayImageData.data[i + 3] = 255;
    }
    rayCtx.putImageData(rayImageData, 0, 0);
}

function rayGenerateTileQueue() {
    rayTileQueue = [];
    const width = rayCanvas.width;
    const height = rayCanvas.height;
    const tilesX = Math.ceil(width / TILE_SIZE);
    const tilesY = Math.ceil(height / TILE_SIZE);
    
    if (raySamples === 0) rayTileConvergence = new Array(tilesX * tilesY).fill(false);

    let tileIndex = 0;
    for (let y = 0; y < height; y += TILE_SIZE) {
        for (let x = 0; x < width; x += TILE_SIZE) {
            
            let shouldRender = true;
            if (rayConfig.adaptiveEnabled && raySamples > 5 && rayTileConvergence[tileIndex]) {
                 shouldRender = false;
            } else if (rayConfig.adaptiveEnabled && raySamples > 5) {
                let totalVariance = 0;
                let pixelCount = 0;
                const endY = Math.min(y + TILE_SIZE, height);
                const endX = Math.min(x + TILE_SIZE, width);
                
                // Checa variância a cada 2 pixels para performance
                for (let vy = y; vy < endY; vy+=2) {
                    for (let vx = x; vx < endX; vx+=2) {
                        const idx = (vy * width + vx) * 4;
                        const N = raySampleCountBuffer[idx]; // Usa o count real do pixel
                        if (N < 2) continue; // Precisa de pelo menos 2 samples pra variância

                        const sumR = rayAccumulationBuffer[idx];
                        const sumSqR = raySumSqBuffer[idx]; 
                        const varR = (sumSqR - (sumR * sumR) / N) / (N - 1);
                        totalVariance += varR;
                        pixelCount++;
                    }
                }
                const avgVariance = (pixelCount > 0) ? (totalVariance / pixelCount) : 1.0;
                if (avgVariance < rayConfig.varianceThreshold) {
                    rayTileConvergence[tileIndex] = true;
                    shouldRender = false;
                }
            }

            if (shouldRender) {
                rayTileQueue.push({
                    startX: x, startY: y,
                    tileW: Math.min(TILE_SIZE, width - x),
                    tileH: Math.min(TILE_SIZE, height - y),
                    width: width, height: height
                });
            }
            tileIndex++;
        }
    }
}

function rayRenderFrame() {
    if (!rayIsRendering) return;
    if (rayTileQueue.length === 0 && rayActiveWorkersCount === 0) {
        rayGenerateTileQueue();
        if (rayTileQueue.length === 0) {
            rayFinalizePass(); 
        } else {
            rayWorkers.forEach(w => rayProcessNextTile(w));
        }
    }
}

function raySetupWorkerListeners() {
    rayWorkers.forEach((worker) => {
        worker.onmessage = (e) => {
            if (e.data.type === 'result') {
                const { startX, startY, tileW, tileH, tileData } = e.data.data;
                const width = rayCanvas.width;
                let tileIdx = 0;
                for (let y = startY; y < startY + tileH; y++) {
                    for (let x = startX; x < startX + tileW; x++) {
                        const bufferIdx = (y * width + x) * 4;
                        const r = tileData[tileIdx++];
                        const g = tileData[tileIdx++];
                        const b = tileData[tileIdx++];
                        const a = tileData[tileIdx++]; // alpha/weight (não usado diretamente)
                        
                        rayAccumulationBuffer[bufferIdx + 0] += r;
                        rayAccumulationBuffer[bufferIdx + 1] += g;
                        rayAccumulationBuffer[bufferIdx + 2] += b;
                        
                        // Incrementa o contador de samples DESTE pixel
                        raySampleCountBuffer[bufferIdx + 0] += 1.0;
                        raySampleCountBuffer[bufferIdx + 1] += 1.0; 
                        raySampleCountBuffer[bufferIdx + 2] += 1.0; 
                        raySampleCountBuffer[bufferIdx + 3] += 1.0; 
                        
                        raySumSqBuffer[bufferIdx + 0] += r*r;
                        raySumSqBuffer[bufferIdx + 1] += g*g;
                        raySumSqBuffer[bufferIdx + 2] += b*b;

                        rayNormalDepthBuffer[bufferIdx + 0] = tileData[tileIdx++]; 
                        rayNormalDepthBuffer[bufferIdx + 1] = tileData[tileIdx++]; 
                        rayNormalDepthBuffer[bufferIdx + 2] = tileData[tileIdx++]; 
                        rayNormalDepthBuffer[bufferIdx + 3] = tileData[tileIdx++]; 
                    }
                }
                // Preview (Divide pelo count local)
                tileIdx = 0;
                for (let y = startY; y < startY + tileH; y++) {
                    for (let x = startX; x < startX + tileW; x++) {
                        const r = tileData[tileIdx]; const g = tileData[tileIdx+1]; const b = tileData[tileIdx+2]; tileIdx += 8; 
                        // Preview simples usa o resultado direto do worker (gamma corrected)
                        // Isso evita flickering na UI enquanto renderiza
                        const pixelIdx = (y * width + x) * 4;
                        rayImageData.data[pixelIdx] = Math.min(255, Math.pow(r, 1/2.2) * 255);
                        rayImageData.data[pixelIdx+1] = Math.min(255, Math.pow(g, 1/2.2) * 255);
                        rayImageData.data[pixelIdx+2] = Math.min(255, Math.pow(b, 1/2.2) * 255);
                        rayImageData.data[pixelIdx+3] = 255;
                    }
                }
                rayCtx.putImageData(rayImageData, 0, 0, startX, startY, tileW, tileH);
                rayActiveWorkersCount--;
                if (rayTileQueue.length > 0) rayProcessNextTile(worker);
                else if (rayActiveWorkersCount === 0) rayFinalizePass();
            }
        };
    });
}

function rayUpdateCamera(threeCamera) {
    rayCamera.position = { x: threeCamera.position.x, y: threeCamera.position.y, z: threeCamera.position.z };
    const direction = new THREE.Vector3();
    threeCamera.getWorldDirection(direction);
    rayCamera.target = {
        x: rayCamera.position.x + direction.x,
        y: rayCamera.position.y + direction.y,
        z: rayCamera.position.z + direction.z
    };
    rayCamera.fov = threeCamera.fov;
    rayCamera.aspect = threeCamera.aspect;
}

function rayStartRendering(selectableObjects, threeCamera) {
    if (rayIsRendering) { rayStopRendering(); return; }
    console.log('=== Ray Tracer: Start (Fixed Adaptive) ===');

    rayCanvas = document.getElementById('renderCanvas');
    if (!rayCanvas) return;
    rayCanvas.style.display = 'block';
    rayCanvas.width = innerWidth * rayConfig.pixelRatio;
    rayCanvas.height = innerHeight * rayConfig.pixelRatio;
    rayCanvas.style.width = innerWidth + 'px';
    rayCanvas.style.height = innerHeight + 'px';
    rayCtx = rayCanvas.getContext('2d', { willReadFrequently: true });

    rayImageData = rayCtx.createImageData(rayCanvas.width, rayCanvas.height);
    rayAccumulationBuffer = new Float32Array(rayCanvas.width * rayCanvas.height * 4);
    raySumSqBuffer = new Float32Array(rayCanvas.width * rayCanvas.height * 4);
    raySampleCountBuffer = new Float32Array(rayCanvas.width * rayCanvas.height * 4); // Novo buffer
    rayNormalDepthBuffer = new Float32Array(rayCanvas.width * rayCanvas.height * 4);
    
    raySamples = 0;
    rayActiveWorkersCount = 0;
    rayTileQueue = [];
    rayTileConvergence = [];

    try {
        raySceneData = rayConvertThreeObjects(selectableObjects);
        if (!raySceneData) { rayStopRendering(); return; }
        rayUpdateCamera(threeCamera);
    } catch (error) {
        console.error('Conversion Error:', error);
        rayStopRendering();
        return;
    }

    if (rayWorkers.length === 0) {
        rayCreateWorkers();
        raySetupWorkerListeners();
    } else {
        raySetupWorkerListeners();
    }

    let readyWorkers = 0;
    const workersToUse = Math.min(rayNumWorkers, rayWorkers.length);
    for (let i = 0; i < workersToUse; i++) {
        const worker = rayWorkers[i];
        const readyHandler = (e) => {
            if (e.data.type === 'ready') {
                readyWorkers++;
                if (readyWorkers === workersToUse) {
                    worker.removeEventListener('message', readyHandler);
                    rayIsRendering = true;
                    rayRenderFrame();
                }
            }
        };
        worker.addEventListener('message', readyHandler);

        const initData = {
            type: 'init',
            data: {
                bvhBounds: raySceneData.bvhBounds,
                bvhContents: raySceneData.bvhContents,
                bvhIndices: raySceneData.bvhIndices,
                lights: raySceneData.lights,
                triangleData: raySceneData.triangleData,
                normalData: raySceneData.normalData, 
                uvData: raySceneData.uvData,
                materialData: raySceneData.materialData,
                textureList: raySceneData.textureList,
                emissiveTrianglesData: raySceneData.emissiveTrianglesData, 
                camera: rayCamera,
                config: rayConfig
            }
        };
        if (raySkyboxData && rayConfig.useSkybox) {
            initData.data.skyboxData = raySkyboxData;
            initData.data.skyboxWidth = raySkyboxWidth;
            initData.data.skyboxHeight = raySkyboxHeight;
            initData.data.useSkybox = true;
        }
        worker.postMessage(initData);
    }
}

function rayStopRendering() {
    if (!rayIsRendering) return;
    rayIsRendering = false;
    if (rayCanvas) rayCanvas.style.display = 'none';
    const progressDiv = document.getElementById('progresso');
    if (progressDiv) progressDiv.innerHTML = 'stopped';
    rayTileQueue = [];
}

function raySetupRenderButton() {
    rayRenderButton = document.getElementById('render');
    if (!rayRenderButton) return;
    rayRenderButton.addEventListener('click', () => {
        if (typeof selectableObjects === 'undefined' || typeof camera === 'undefined') return;
        if (rayIsRendering) {
            rayStopRendering();
            rayRenderButton.textContent = 'Iniciar Render';
        } else {
            rayStartRendering(selectableObjects, camera);
            rayRenderButton.textContent = 'Parar Render';
        }
    });
}

function raySetPixelRatio(ratio) { rayConfig.pixelRatio = Math.max(0.1, Math.min(1.0, ratio)); }
function raySetMaxSamples(samples) { rayConfig.maxSamples = Math.max(1, samples); }
function raySetMaxBounces(bounces) { rayConfig.maxBounces = Math.max(1, Math.min(16, bounces)); }
function raySetDenoise(enabled) { rayConfig.denoise = enabled; }
function raySetAO(enabled, intensity=1.0, radius=1.5, samples=8) {
    rayConfig.aoEnabled = enabled;
    rayConfig.aoIntensity = intensity;
    rayConfig.aoRadius = radius;
    rayConfig.aoSamples = samples;
    console.log(`AO Configured: ${enabled ? 'ON' : 'OFF'}`);
}

window.addEventListener('beforeunload', () => { rayWorkers.forEach(worker => worker.terminate()); rayWorkers = []; });
if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', raySetupRenderButton); } else { raySetupRenderButton(); }

// EXPORTS
window.rayLoadSkybox = rayLoadSkybox;
window.raySetPixelRatio = raySetPixelRatio;
window.raySetMaxSamples = raySetMaxSamples;
window.raySetMaxBounces = raySetMaxBounces;
window.raySetDenoise = raySetDenoise;
window.raySetAO = raySetAO;

//rayLoadSkybox('img/30 Sem Título_20251128140027.png');